TIL 22.07.14
1. ch4, ch5를 진행함.
2. 07.19 배열부분 추가.
   
# 조건문과 반복문
기본적인 내용들은 이미 알고있어서 훑고 넘어가는 느낌으로 공부함.

## if문에서 사용되는 조건식
일반적으로 **비교연산자와 논리연산자**로 구성됨.  
  
예시)
| 조건식 | 참일 조건 |
|---|:---:|
| 90 <= x && x <= 100 | x가 90이상 100 이하일 때 |
| x%3==0 && x%2!=0 | x가 3의 배수지만, 2의 배수는 아닐 때 |
| ch == 'y' (or표시) ch == 'Y' | ch가 y또는 Y일 때 |
| str.equals("hello") | str의  내용이 hello일 때(대소문자 구분) |
| str.equalsIgnoreCase("hello") |str의 내용이 hello일 때(대소문자 구분 안 함) |
| | |

## 조건식 / 반복문
```
int x = 0;
		
		System.out.printf("x=%d일 때, 참인 것은 %n", x);
		
		if(x==0) System.out.println("x==0");
		if(x!=0) System.out.println("x!=0");
		if(!(x==0)) System.out.println("!(x==0)");
		if(!(x!=0)) System.out.println("!(x!=0)");
		System.out.println();
		
		x=1;
		System.out.printf("x=%d일 때, 참인 것은? %n", x);
		if(x==0) System.out.println("x==0");
		if(x!=0) System.out.println("x!=0");
		if(!(x==0)) System.out.println("!(x==0)");
		if(!(x!=0)) System.out.println("!(x!=0)");
```
if문은 위처럼 쓸 수 있지만 블럭으로 묶어서 사용하는 게 좋음.

```
for (int i = 1; i <= 10; i++)
		{
			System.out.println(i);
		}
		
		System.out.println("-------"); //위와 아래는 동일한 결과가 나옴
		
		int j = 1;
		while (j<=10)
		{
			System.out.println(j);
			j++;
		}
```
while은 조건식 생략이 불가능함.

`for(;;) { }` ` while(true) { } ` 둘 다 조건식이 항상 참이라는 뜻임.

```
int i =5;
		
while (i--!=0) { //후위형이기 때문에 조건식이 평가된 후에 i가 감소됨
	System.out.println(i+"-I can do it.");
}
```

```
int i=11;

		System.out.println("자, 이제 카운트다운을 시작합니다.");

		while(i--!=0) {
			System.out.println(i);

			for(int j=0;j<2_000_000_000;j++) { //조건식과 증감식을 2_000_000_000번 반복하면서 시간을 보내게 만듦.
					; //빈문장
			}
		}

		System.out.println("GAME OVER");
```

```
//숫자를 입력받고, 각 자리의 합을 구하는 예제
int num = 0; 
		int sum = 0;

		System.out.print("숫자를 입력하세요.(예:12345)>");
		Scanner scanner = new Scanner(System.in);
		String tmp = scanner.nextLine(); // 화면을 통해 입력받은 내용을 tmp에 저장
		num = Integer.parseInt(tmp);      // 입력받은 문자열(tmp)을 숫자로 변환

		while(num!=0) {    
			// num을 10으로 나눈 나머지를 sum에 더함
			sum += num%10; 	// sum = sum + num%10;
			System.out.printf("sum=%3d num=%d%n", sum, num);

			num /= 10;  // num = num / 10;  num을 10으로 나눈 값을 다시 num에 저장
		}
		
		System.out.println("각 자리수의 합:"+ sum);
```

```
//do-while
		//기본적으로 while문과 같으나 블럭을 먼저 수행한 후에 조건식을 평가한다는 차이가 있음.
		//숫자 맞히기 게임 예제
		int input  = 0;
		int answer = 0;

		answer = (int)(Math.random() * 100) + 1; // 1~100사이의 임의의 수를 저장
		Scanner scanner = new Scanner(System.in);

		do {
			System.out.print("1과 100사이의 정수를 입력하세요.>");

			String tmp = scanner.nextLine();
			input = Integer.parseInt(tmp);

			if(input > answer) {
				System.out.println("더 작은 수로 다시 시도해보세요.");	
			} else if(input < answer) {
				System.out.println("더 큰 수로 다시 시도해보세요.");			
			}
		} while(input!=answer);

		System.out.println("정답입니다.");
```

### 이름 붙은 반복문
break문은 근접한 단 하나의 반복문만 벗어날 수 있기 때문에, 여러 개의 반복문이 중첩된 경우엔 벗어날 수 없음.  
이럴 때는 중첩 반복문에 이름을 붙이고 break문과 continue문에 이름을 지정해 줌으로써 벗어날 수 있음.  

```
//이름 붙은 반복문
		
		//for문 이름: Loop1
		Loop1 : for(int i =2; i <= 9; i++) {
            //이름을 붙이면 하나 이상의 반복문도 벗어날 수 있음.
			for (int j= 1; j<=9;j++) {
				if(j==5)
					break Loop1; //조건식이 맞다면 Loop1 벗어남.
//				break;
//				continue Loop1;
//				continue;
				System.out.println(i+"*"+j+"="+ i*j);
			}//j 끝
			System.out.println();
			}//Loop1 끝
```

---
# 배열

1. 배열을 다룰 때 가장 중요한 것은, inde의 범위가 아닌 값을 index로 사용하지 않아야 한다는 것.  
예를 들어 길이가 5인 배열의 index범위는 0~4인데, 5를 index로 사용하면 안 된다는 것.  

2. 배열의 길이가 0인 배열도 생성이 가능하다.

-07/18

3. 배열은 한 번 생성하면 그 길이를 변경할 수 없다. 더 많은 저장공간이 필요한다면, 큰 배열을 새로 만들고 이전 배열로부터 내용을 복사해야한다.  
배열을 복사하는 방법은 For문을 사용하는 방식과, System.arraycopy()를 사용하는 방식. 총 두 가지가 있다.

   1. For 방식
   ```
   //for으로 복사하는 방법
   int[] arr = new int[5];
   ...
   int[] tmp = new int[arr.length*2]; //기존 배열보다 2배가 큰 배열 생성

   for(int i=0; i<arr.length; i++) {
	tmp [i] = arr[i]; //arr[i]의 값을 tmp[i]에 저장
   }

   arr = tmp; // 참조변수 arr이 새로운 배열을 가리키게 함.
   ```
   ```
   //for 복사 예시
		int[] arr = new int[5];
		
		for(int i=0; i<arr.length; i++) {
			arr[i] = i + 1;
			}
		
		System.out.println("변경 전 = arr.length: " + arr.length);
		for(int i=0; i<arr.length; i++) {
			System.out.println("arr["+i+"]: " + arr[i]);
			}
		
		int[] tmp = new int[arr.length*2]; //기존 배열보다 2배가 큰 배열 생성

		for(int i=0; i<arr.length; i++) {
		tmp [i] = arr[i]; //arr[i]의 값을 tmp[i]에 저장
		}

		arr = tmp; // 참조변수 arr이 새로운 배열을 가리키게 함.
		
		System.out.println("변경 후 = arr.length: " + arr.length);
		for(int i=0; i<arr.length; i++) {
			System.out.println("arr["+i+"]: " + arr[i]);
			}
   ```

   2. System.arraycopy() 방식  
   >>배열의 복사는 for문보다 System.arraycopy() 방식을 사용하는 것이 효율적임.

```
for(int i=0; i <num.length; i++) { 
	newNum[i] = num[i];
}
```
위의 방식을
```
System.arraycopy(num,0,newNum,0,num.length);
//arraycopy()를 호출할 때는 어느 배열의 몇 번째 요소에서 어느 배열로 몇 번째 요소로 몇 개의 값을 복사할 것인지 지정해야함.
//이 코드에서는 num, [0]에서 nueNum, [0]으로 num.length개의 데이터를 복사한다는 의미임.
```
이렇게 쓸 수 있음.

```
char[] abc= {'A','B','C','D'};
		char[] num = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};
		System.out.println(abc);
		System.out.println(num);
		
		// 배열 abc와 num을 붙여서 하나의 배열(result)로 만든다.
		char [] result = new char [abc.length+num.length];
		System.arraycopy(abc, 0, result, 0, abc.length);
		System.arraycopy(num, 0, result, abc.length, num.length);
		System.out.println(result);
		
		// 배열 abc를 num의 첫 번째 위치부터 배열 abc의 길이만큼 복사
		System.arraycopy(abc, 0, num, 0, abc.length);
		System.out.println(num);
		
		//num의 인덱스6 위치에 세 개를 복사
		System.arraycopy(abc, 0, num, 6, 3);
		System.out.println(num);
		/*
		결과
		ABCD
		0123456789
		ABCD0123456789
		ABCD456789
		ABCD45ABC9
		*/
```
***제에에에발 인덱스 위치 햇갈리지 말자! 이번에 벌써 몇 번째냐!**

## 배열의 활용
```
//총합과 평균
		int sum=0;
		float average = 0f;
		
		int[] score = {100, 88, 100, 100, 90};
		
		for(int i=0; i< score.length; i++) {
			sum += score[i]; //배열에 있는 값을 모두 더함
		}
		average = sum / (float)score.length; //계산 결과를 float로 얻기 위함
		
		System.out.println("총점: " +sum);
		System.out.println("평균: " +average);
```

```
//최대최소
		int [] score = { 79,88,91,33,100,55,95};
		
		int max = score[0]; //배열 첫 번째 값. 최대값을 초기화함
		int min = score[0]; // 최소값을 초기화
		
		for(int i=1; i < score.length;i++) { //두번째 요소부터 읽기위해 i를 1로 초기화
			if(score[i] > max) {//배열의 두 번째 요소부터 max와 비교. 만일 max보다 크다면 max에 저장
				max = score[i];
			} else if(score[i] < min) {
				min = score[i];
			}
		}

		System.out.println("최대값 :" + max);
		System.out.println("최소값 :" + min);
```
```
//섞기
		int[] numArr = new int[10];

		for (int i=0; i < numArr.length ; i++ ) {
             numArr[i] = i;  // 배열을 0~9의 숫자로 초기화한다.
			System.out.print(numArr[i]);  
		}
		System.out.println();

		for (int i=0; i < 100; i++ ) {
			int n = (int)(Math.random() * 10); // 0~9중의 한 값을 임의로 얻음.

			int tmp = numArr[0];
			numArr[0] = numArr[n];
			numArr[n] = tmp;
			//random()을 이용해서 배열의 임의의 위치에 있는 값과 배열의 첫 번째 요소	
			//numArr[0]값을 교환하는 일을 100번 반복함.
		}

		for (int i=0; i < numArr.length ; i++ )
			System.out.print(numArr[i]);
	}
```
```
//로또번호 생성
		// 45개의 정수값을 저장하기 위한 배열 생성. 
		int[] ball = new int[45];
		
		// 배열의 각 요소에 1~45의 값을 저장한다. 
		for(int i=0; i < ball.length; i++)
			ball[i] = i+1;// ball[0]에 1이 저장된다.
		
		int temp = 0;// 두 값을 바꾸는데 사용할 임시변수
		int j = 0;// 임의의 값을 얻어서 저장할 변수
		
		// 배열의 i번째 요소와 임의의 요소에 저장된 값을 서로 바꿔서 값을 섞는다.
		// 0번째 부터 5번째 요소까지 모두 6개만 바꾼다.
		for(int i=0; i < 6; i++) {
			j = (int)(Math.random() * 45);// 0~44범위의 임의의 값을 얻는다.
			temp = ball[i];
			ball[i] = ball[j];
			ball[j] = temp;
		}

		// 배열 ball의 앞에서 부터 6개의 요소를 출력한다.
		for(int i=0; i < 6; i++)
			System.out.printf("ball[%d]=%d%n", i, ball[i]);
```
```
//임의의 값으로 배열 채우기
		int[] code = { -4, -1, 3, 6, 11 };  // 불연속적인 값들로 구성된 배열
		int[] arr = new int[10];

		for (int i=0; i < arr.length ; i++ ) {
			int tmp = (int)(Math.random() * code.length); //code길이 5 = tmp = 0~4
			arr[i] = code[tmp];//tmp에 01234중 하나가 저장됨.
			//만약 i가 0이고, tmp가 4라면 arr[0]에는 11이 들어감.
		}

		System.out.println(Arrays.toString(arr));
```
```
//버블정렬
//배열의 길이가 n일때, 배열의 첫 번째부터 n-1까지 요소에 대해 근접한 값과 크기를 비교하여 자리바꿈을 반복함.
int[] numArr = new int[10];

		for (int i=0; i < numArr.length ; i++ ) {
			System.out.print(numArr[i] = (int)(Math.random() * 10));
		}
		System.out.println();

		for (int i=0; i < numArr.length-1 ; i++ ) {
			boolean changed = false;	// 자리바꿈이 발생했는지를 체크한다.

			for (int j=0; j < numArr.length-1-i ;j++) {
				if(numArr[j] > numArr[j+1]) { // 옆의 값이 작으면 서로 바꾼다.
					int temp = numArr[j];
					numArr[j] = numArr[j+1];
					numArr[j+1] = temp;
					changed = true;	// 자리바꿈이 발생했으니 changed를 true로.
				}
			} // end for j

			if (!changed) break;	// 자리바꿈이 없으면 반복문을 벗어난다.

			for(int k=0; k<numArr.length;k++)
				System.out.print(numArr[k]); // 정렬된 결과를 출력한다.
			System.out.println();
```

### string 배열
추가예정